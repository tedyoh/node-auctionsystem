 ********1. 프로젝트 구조 갖추기*******
[package.jsoncf]
npm i
npm i sequelize-cli mysql2
npx sequelize init

[models/user.js]
'use strict';

const Sequelize = require('sequelize');

module.exports = class User extends Sequelize.Model {
    static init(sequelize) {
        return super.init({
            email : {
                type : Sequelize.STRING(40),
                allowNull : false,
                unique : true,
            },
            nick : {
                type : Sequelize.STRING(15),
                allowNull : false,
            },
            password : {
                type : Sequelize.STRING(100),
                allowNull : true,
            },
            money : {
                type : Sequelize.INTEGER,
                allowNull : false,
                defaultValue : 0,
            },
        }, {
            sequelize,
            timestamps : true,
            paranoid : true,
            modelName : 'User',
            tableName : 'users',
            charset : 'utf8',
            collate : 'utf8_general_ci',
        });
    }

    static associate(db) {
        db.User.hasMany(db.Auction);
    }
};

사용자 모델은 이메일(email), 닉네임(nick), 비밀번호(password), 보유자금(money)으로 구성됩니다. 
사용자가 입찰을 여러번 할 수 있으므로 사용자 모델과 경매 모델도 일대다 관계입니다. 

[models/good.js]
'use strict';

const Sequelize = require('sequelize');

module.exports = class Good extends Sequelize.Model {
    static init(sequelize) {
        return super.init({
            name : {
                type : Sequelize.STRING(40),
                allowNull : false,
            },
            img : {
                type : Sequelize.STRING(20),
                allowNull : true,
            },
            price : {
                type : Sequelize.INTEGER,
                allowNull : false,
                defaultValue : 0,
            },
        }, {
            sequelize,
            timestamps : true,
            modelName : 'Good',
            tableName : "goods",
            charset : 'utf8',
            collate : 'utf8_general_ci',
        });
    }

    static associate(db) {
        db.Good.belongsTo(db.User, {as:'Owner'});
        db.Good.belongsTo(db.User, {as:'Sold'});
        db.Good.hasMany(db.Auction);
    }
};

상품 모델은 상품명(name), 상품사진(img), 시작가격(price)으로 구성됩니다. 
사용자 모델과 상품 모델간에는 일대다 관계가 두번 적용됩니다. 
사용자가 여러 상품을 등록할 수 있고, 사용자가 여러 상품을 낙찰 받을 수 있기 때문입니다. 
등록한 상품과 낙찰받은 상품, 두 관계를 구별하기 위해 as 속성에 각각 Owner, Sold 로 관계명을 적었습니다. 
각각 OwnerId , SoldId 컬럼으로 상품모델에 추가됩니다. 
한 상품에 여러 명이 입찰하므로 상품 모델과 경매 모델도 일대 다 관계입니다. 

[models/auction.js]
'use strict';

const Sequelize = require('sequelize');
const { config } = require('../node_modules/dotenv/types');

module.exports = class Auction extends Sequelize.Model {
    static init(sequelize) {
        return super.init({
            bid : {
                type : Sequelize.INTEGER,
                allowNull : false,
                defaultValue : 0,
            },
            msg : {
                type : Sequelize.STRING(100),
                allowNull : true,
            },
        }, {
            sequelize,
            timestamps : true,
            paranoid : true,
            modelName : 'Auction',
            tableName : 'auctions',
            charset : 'utf8',
            collate : 'utf8_general_ci',
        });
    }

    static associate(db) {
        db.Auction.belongsTo(db.User);
        db.Auction.belongsTo(db.Good);
    }
};

마지막으로 경매 모델은 입찰가(bid)와 입찰 시 메시지(msg)로 구성됩니다. 
입찰 시 메시지는 null 이어도 됩니다. 
경매 모델은 사용자 모델 및 상품 모델과 일대다 관계에 있습니다. 
경매 모델에는 UserId 컬럼과 GoodId  컬럼이 생성됩니다. 

모델을 생성 한 후에 모델을 데이터 베이스와 서버와 연결합니다. 
nodeauction 데이터베이스를 생성해야 하므로 config.json을 데이터베이스에 맞게 수정합니다. 
[config/config.json]
{
  "development": {
    "username": "root",
    "password": "1234",
    "database": "nodeauction",
    "host": "127.0.0.1",
    "dialect": "mysql"
  },
  .....
}

npx sequelize db:create 명령어로 데이터베이스를 생성합니다. 

modles/index.js를 다음과 같이 바꿉니다. 
[modles/index.js]
'use strict';

const Sequelize = require('sequelize');
const User = require('./user');
const Good = require('./good');
const Auction = require('./auction');

const env = process.env.NODE_ENV || 'development';
const config = require('../config/config')[env];
const db = {};

const sequelize = new Sequelize(
  config.database, config.username, config.password, config,
);

db.sequelize = sequelize;
db.User = User;
db.Good = Good;
db.Auction = Auction;

User.init(sequelize);
Good.init(sequelize);
Auction.init(sequelize);

User.associate(db);
Good.associate(db);
Auction.associate(db);

module.exports = db;

이제 로그인을 위한 패스포트 설정이 필요합니다. 
이번에는 단순히 passport-local 만 사용하겠습니다. 
[passport/localStrategy.js]
'use strict';

const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const bcrypt = require('bcrypt');
const User = require('../models/user');

module.exports = ()=> {
    passport.use(new LocalStrategy({
        usernameField : 'email',
        passwordField : 'password',
    }, async(email, password, done)=> {
        try {
            const exUser = await User.findOne({where:{email}});
            if(exUser) {
                const result = await bcrypt.compare(password, exUser.password);
                if(result) {
                    done(null, exUser);
                } else {
                    done(null, false, {message : '비밀번호가 일치 않습니다.'});
                }
            } else {
                done(null, false, {message : '가입되지 않은 회원입니다.'});
            }
        } catch(error) {
            console.error(error);
            done(error);
        }
    }));
};

[passport/index.js]
'use strict';

const passport = require('passport');

const local = require('./localStrategy');
const User = require('./user');

module.exports = () => {
    passport.serializeUser((user, done)=> {
        done(null, user.id);
    });

    passport.deserializeUser((id, done)=> {
        user.findOne({where : id})
        .then(user=>done(null, user))
        .catch(err=>done(err))
    });

    local();
};

(9장 passport 참조내용)
모듈 내부를 보면 passport.serializeUser와 passport.deserializeUser가 있습니다. 
이부분이 Passport 를 이해하는 핵심입니다. 
serializeUser는 로그인시 실행되며, 
req.session(세션) 객체에 어떤 데이터를 저장할지 정하는 메서드 입니다. 
매개변수로 user를 받고 나서, done 함수에 두번째 인수로 user.id를 넘기고 있습니다. 
매개 변수 user가 어디서 오는지는 나중에 설명합니다. 
지금은 그냥 사용자 정보가 들어 있다고 생각하면 됩니다. 
done 함수의 첫번째 인수는 에러 발생시 사용하는 것이고, 
두 번째 인수에는 저장하고 싶은 데이터를 넣습니다. 
로그인시 데이터를 세션에 저장하는데 세션에 사용자 정보를 모두 저장하면 세션의 용량이 커지고
데이터 일관성에 문제가 발생하므로 사용자의 아이디만 저장하라고 명령한 것입니다. 
serializeUser가 로그인 시에만 실행된다면 deseriallizeUser는 매 요청 시 실행됩니다. 
passport.session 미들웨어가 이 메서드를 호출합니다. 
serializeUser의 done의 두번째 인수로 넣었던 데이터가 deserializeUser에서 세션에 저장했던 아이디를 받아
데이터베이스에서 사용자 정보를 조회합니다. 
조회한 정보를 req.user에 저장하므로 앞으로 req.user를 통해 로그인한 사용자의 정보를 가져올 수 있습니다. 

즉 serializeUser는 사용자 정보 객체를 세션에 아이디로 저장하는 것이고,
deserializeUser는 세션에 저장한 아이디를 통해 사용자 정보 객체를 불러오는 것입니다. 
세션에 불필요한 데이터를 담아두지 않기 위한 과정입니다. 

전체 과정은 다음과 같습니다. 
1. 라우터를 통해 로그인 요청이 들어옴
2. 라우터에서 passport.authenticate 메서드 호출
3. 로그인 전략 수행
4. 로그인 성공 시 사용자 정보 객체와 함께 req.login 호출
5. req.login 메서드가 passport.serializeUser 호출
6. req.session에 사용자 아이디만 저장
7. 로그인 완료

로그인 이후의 과정은 다음과 같습니다. 
1. 요청이 들어옴
2. 라우터에 요청이 도달하기 전에 passport.session 미들웨어가 passport.deserializeUser 메서드 호출
3. req.session에 저장된 아이디로 데이터베이스에서 사용자 조회
4. 조회된 사용자 정보를 req.user에 저장
5. 라우터에서 req.user 객체 사용 가능

세션에 저장된 아이디로 사용자 정보를 조회할 때 팔로잉 목록과 팔로워 목록도 같이 조회합니다. 
include에서 계속 attributes를 지정하고 있는데, 이는 실수로 비밀번호를 조회하는 것을 
방지하기 위해서입니다. 

deserializeUser 캐싱하기
: 라우터가 실행되기 전에 deserializeUser가 먼저 실행됩니다. 
따라서 모든 요청이 들어올 때마다 매번 사용자 정보를 조회하게 됩니다. 
서비스의 규모가 커질수록 더 많은 요청이 들어오게 되고, 그로 인해 데이터베이스도 
더 큰 부담이 주어집니다. 따라서 사용자 정보가 빈번하게 바뀌는 것이 아니라면
캐싱을 해두는 것이 좋습니다. 다만, 캐싱이 유지되는 동안 팔로워와 팔로잉 정보가 갱신되지
않는 단점이 있으므로 캐싱 시간은 서비스 정책에 따라 조절해야 합니다. 
실제 서비스에서는 메모리에 캐싱하기보다는 레디스 같은 데이터베이스에 사용자 정보를 캐싱합니다. 


로그인을 위한 라우터와 미들웨어도 추가합니다. 
9장에서 배웠던것과 크게 다르지 않습니다. 

[routes/auth.js]
'use strict';

const passport = require('passport');

const local = require('./localStrategy');
const User = require('./user');

module.exports = () => {
    passport.serializeUser((user, done)=> {
        done(null, user.id);
    });

    passport.deserializeUser((id, done)=> {
        user.findOne({where : id})
        .then(user=>done(null, user))
        .catch(err=>done(err))
    });

    local();
};

1. 회원가입 라우터
: 기존에 같은 이메일로 가입한 사용자가 있는지 조회한 뒤, 있다면 회원가입 페이지로 되돌려 보냅니다. 
단, 주소뒤에 에러를 쿼리스트링으로 표시합니다. 
같은 이메일로 가입한 사용자가 없다면 비밀번호를 암호화하고, 사용자 정보를 생성합니다. 
회원 가입시 비밀번호는 암호화해서 저장해야 합니다. 
이번에는 bcrypt 모듈을 사용했습니다. (crypt 모듈의 pbkdf2 메서드를 사용해서 암호화할 수도 있습니다.)
bcrypt 모듈의 hash 메서드를 사용하면 손쉽게 비밀번호를 암호화 할 수 있습니다. 
bcrypt의 두번째 인수는 pbkdf2의 반복 횟수와 비슷한 기능을 합니다.
숫자가 커질수록 비밀번호를 알아내기 어려워지지만 암호화 시간도 오래 걸립니다. 
12 이상을 추천하며, 31까지 사용할 수 있습니다. 
프로미스를 지원하는 함수이므로 await를 사용했습니다. 

2. 로그인 라우터 
: 로그인 요청이 들어오면 passport.authenticate('local') 미들웨어가 로컬 로그인 전략을
수행합니다. 미들웨어인데 라우터 미들웨어 안에 들어있습니다. 미들웨어에 사용자 정의 기능을
추가하고 싶을 때 이렇게 할 수 있습니다. 이럴 때는 내부 미들웨어에 (req, res, next)를 
인수로 제공해서 호출하면 됩니다. 
전략 코드는 잠시 후에 작성합니다. 전략이 성공하거나 실패하면 authenticate 메서드의 콜백 함수가
실행됩니다. 콜백 함수의 첫 번째 매개변수 (authErr) 값이 있다면 실패한 것입니다. 
두 번째 매개변수 값이 있다면 성공한 것이고, req.login 메서드를 호출합니다. 
Passport는 req 객체에 login과 logout 메서드를 추가합니다. 
req.login은 passport.serializeUser를 호출합니다. req.login에 제공하는 user 객체가 
serializeUser로 넘어가게 됩니다. 

3.로그아웃 라우터
:req.logout 메서드는 req.user 객체를 제거하고 req.session.destroy는 req.session 
객체의 내용을 제거합니다.
세션 정보를 지운 후 메인 페이지로 되돌아갑니다.
로그인이 해제 되어 있을 것입니다. 

[routes/middlewares.js]
'use strict';

exports.isLoggedIn = (req, res, next) => {
    if(req.isAuthenticated()) {
        next();
    } else {
        res.status(403).send('로그인 필요');
    }
};

exports.isNotLoggedIn = (req, res, next) => {
    if(!req.isAuthenticated()) {
        next();
    } else {
        const message = encodeURIComponent('로그인한 상태입니다.');
        res.redirect(`/?error=${message}`);
    }
};

마지막으로 .env 파일과 서버 코드(app.js)를 작성합니다. 시퀄라이즈와 패스포트를 모두 서버에 연결합니다.

[.env]
COOKIE_SECRET = auction

[app.js]
'use strict';

const express = require('express');
const path = require('path');
const morgan = requrie('morgan');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const passport = require('passport');
const nunjucks = require('nunjucks');
const dotenv = require('dotenv');
//https://brunch.co.kr/@topherlee/73 => dotenv
dotenv.config();
const indexRouter = require('./routes/index');
const authRouter = require('./routes/auth');
const {Sequelize} = require('./models');
const passportConfig = require('./passport');


const app = express();
passportConfig();
app.set('port', process.env.PORT || 8010);
app.set('view engine', 'html');
nunjucks.configure('views', {
    express : app,
    watch : true,
});
sequelize.sync({force:false}) 
//이 옵션을 true로 설정하면 서버 실행시 마다 테이블을 재 생성합니다. 테이블을 잘못 만든 경우에 true로 설정하면 됩니다 .
.then(()=> {
    console.log('데이터베이스 연결 성공');
})
.catch((err) => {
    console.error(err);
});

const sessionMiddleware = session({
    resave : false,
    saveUninitialized : false,
    secret : process.env.COOKIE_SECRET,
    cookie : {
        httpOnly : true,
        secure : false,
    },
});

/*
express-session
세션 관리용 미들웨어입니다. 
로그인등의 이유로 세션을 구현하거나, 특정 사용자를 위한 데이터를 임시적으로 저장해 둘 때 매우 유용합니다. 
세션은 사용자별로 req.session 객체 안에 유지 됩니다. 

app.use(session({
    resave: false,
    saveUninitialized: false,
    secret: process.env.COOKIE_SCRECT,
    cookie: {
        httpOnly: true,
        secure: false,
    },
    name: 'session-cookie',
}));
express-session은 cookie-parser 미들웨어 뒤에 놓는 것이 안전합니다. 
express-session은 인수로 세션에 대한 설정을 받습니다. 
resave는 요청이 올 때 세션에 수정 사항이 생기지 않더라도 세션을 다시 저장할 지 설정하는 것이고, 
saveUninitialized는 세션에 저장할 내역이 없더라도 처음부터 세션을 생성할 지 설정하는 것입니다. 
둘다 필요가 없으면 false로 설정
express-session은 세션 관리 시 클라이언트에 쿠키를 보냅니다. 
4.3절에서 배운 세션 쿠키가 이것 입니다. 
안전하게 쿠키를 전송하려면 쿠키에 서명을 추가해야 하고, 쿠키를 서명하는데 secret의 값이 필요합니다. 
cookie-parser의 secret과 같게 설정하는 것이 좋습니다. 
세션 쿠키의 이름은 name 옵션으로 설정합니다. 기본 이름은 connect.sid입니다. 
cookie 옵션은 세션 쿠키에 대한 설정입니다. 
domain, expires, httpOnly, maxAge, path, secure, sameSite 등 일반적인 쿠키 옵션이 모두 제공됩니다. 
현재 httpOnly를 true로 설정해 클라이언트에서 쿠키를 확인하지 못하도록 했고, secure는 false로 해서   
https가 아닌 환경에서도 사용할 수 있게 했습니다. 
배포시에는 https를 적용하고 secure도 true로 설정하는 것이 좋습니다. 

예제 코드에는 나와 있지 않지만, store라는 옵션도 있습니다. 
현재는 메모리에 세션을 저장하도록 되어 있습니다. 
문제는 서버를 재 시작하면 메모리가 초기화 되어 세션이 모두 사라진다는 것입니다. 
따라서 배포시에는 store에 데이터베이스를 연결해서 세션을 유지하는 것이 좋습니다. 
보통 레디스가 자주 쓰입니다. 

req.session.name = 'zerocho'; //세션 등록
req.sessionID; //세션 아이디 확인
req.session.destroy(); // 세션 모두 제거 

express-session 으로 만들어진 req.session 객체에 값을 대입하거나 삭제해서 세션을 변경할 수 있습니다. 
나중에 세션을 한번에 삭제하려면 req.session.destroy 메서드를 호출하면 됩니다. 
현재 세션의 아이디는 req.sessionID로 확인 할 수 있습니다. 
세션을 강제로 저장하기 위해 req.session.save 메서드가 존재하지만, 
일반적으로 요청이 끝날 때 자도응로 호출되므로 직접 save 메서드를 호출할 일은 거의 없습니다.

express-session에서 서명한 쿠키 앞에는 s:이 붙습니다. 실제로는 encodeURLComponenet 함수가 
실행되어 s%3A가 됩니다. 
s%3A의 뒷부분이 실제 암포화된 쿠키 내용입니다. 
앞에 s%3A가 붙은 경우, 이 쿠키가 express-session 미들웨어에 의해 암호화된 것이라고 생각하면 됩니다. 
*/

app.use(morgan('dev'));
app.use(express.static(path.join(__dirname, 'public')));
app.use('/img', express.static(path.join(__dirname, 'uploads')));
/*
static 미들웨어는 정적인 파일들을 제공하는 라우터 역할을 합니다. 
기본적으로 제공되기에 따로 설치할 필요없이 express 객체 안에서 꺼내 장착하면 됩니다. 
다음과 같이 사용합니다. 

app.use('요청 경로', express.static('실제 경로'));
app.use('/', express.static(path.join(__dirname, 'public')));

함수의 인수로 정적 파일드링 담겨 있는 폴더를 지정하면 됩니다. 
현재 public폴더가 지정되어 있습니다. 
예를 들어 public/stylesheets/style.css는 
http://localhost:3000/stylesheets/style.css로 접근할 수 있습니다. 
piblic 폴더를 만들고 css나 js, 이미지 파일들을 public 폴더에 넣으면 
브라우저에서 접근할 수 있게 됩니다. 

실제 서버의 폴더 경로에는 public이 들어 있지만, 요청 주소에는 public이
들어 있지 않다는 점을 주목해 주세요. 
서버의 폴더 경로와 요청 경로가 다르므로 외부인이 서버의 구조를 쉽게 파악 살 수 없습니다. 
이는 보안에 큰 도움이 됩니다. 

또한 정적 파일들을 알아서 제공해 주므로 4.3절처럼 fs.readFile로 파일을 
직접 읽어서 전송할 필요가 없습니다. 
만약 요청 경로에 해당하는 파일이 없으면 알아서 내부적으로 
next를 호출합니다. 
만약 파일을 발경했다면 다음 미들웨어는 실행되지 않습니다. 
응답으로 파일을 보내고 next를 호출하지 않으니깐요.
*/
app.use(express.json());
app.use(express.urlencoded({extended:false}));
/*
요청의 본문에 있는 데이터를 해석해서 req.body 객체로 만들어주는 미들웨어 입니다. 
보통 폼 데이터나 AJAX 요청의 데이터를 처리합니다. 
단, 멀티 파트(이미지, 동영상, 파일)데이터는 처리하지 못합니다. 
그 경우에는 뒤에 나오는 multer 모듈을 사용하면 됩니다.

body-parser 미들 웨어는 다음과 같이 사용합니다. 

app.use(express.json());
app.use(express.urlencoded({ extended: false }));

<참조>
$npm install body-parser
const bodyParser = require('body-parser');
app.use(bodyParser.raw());
app.use(bodyParser.text());

요청 데이터 종류를 간단히 살펴봅시다. JSON은 JSON 형식의 데이터 전달 방식이고,
URL-encoded는 주소 형식으로 데이터를 보내는 방식입니다. 
폼 전송은 URL-encoded 방식을 주로 사용합니다.
urlencoded 메서드를 보면 {extended : false}라는 옵션이 들어 있습니다. 
이 옵션이 false면 노드의 querystring모듈을 사용하여 쿼리 스트링을 해석하고, 
true이면 qs 모듈을 사용하여 쿼리 스트링을 해석합니다. 
qs 모듈은 내장 모듈이 아니라 npm 패키지이며, querystring 모듈의 기능을 좀더 
확장한 모듈입니다. 

참고>
4.2절에서 POST와 PUT 요청의 본문을 전달 받으려면 req.on('data')와 req.on('end')로
스트림을 사용해야 했던 것을 기억하나요? 
body-parser를 사용하면 그럴 필요가 없습니다. 
이 패키지가 내부적으로 스트림을 처리해 req.body에 추가합니다. 

예를 들어 JSON형식으로 {name : 'zerocho', book : 'nodejs'}를 본문으로 보낸다면
req.body에 그대로 들어갑니다. 
URL-encoded 형식으로 name=zerocho&book=nodejs를 본문으로 보낸다면 
req.body에 {name : 'zerocho', book : 'nodejs'}가 들어갑니다. 
*/

app.use(cookieParser(process.env.COOKIE_SECRET));
/*
cookie-parser는 요청에 동봉된 쿠키를 해석해 req.cookie 객체로 만듭니다. 
4.3절의 parseCookies 함수와 기능이 비슷합니다. 
cookie-parser 미들웨어는 다음과 같이 사용합니다. 

app.use(cookieParser(비밀키));
app.use(cookieParser(process.env.COOKIE_SCRECT));

해석된 쿠키들은 req.cookies 객체에 들어갑니다. 
예를 들어 name=zerocho 쿠키를 보냈다면 req.cookies는 {name : 'zerocho'}가 됩니다. 
유효 기간이 지난 쿠키는 알아서 걸러냅니다. 

첫 번째 인수로 비밀키를 넣어 줄수 있습니다. 서명된 쿠키가 있는 경우, 제공한 비밀 키를 통해 해당 
쿠키가 내 서버가 만든 쿠키임을 검증할 수 있습니다. 쿠키는 클라이언트에서 위조하기 쉬우므로 
비밀 키를 통해 만들어내 서명을 쿠키 값 뒤에 붙입니다. 
서명이 붙으면 쿠키가 name=zerocho.sign과 같은 모양이 됩니다. 
서명된 쿠키는 req.cookies 대신 req.signedCookies 객체에 들어 있습니다. 

cookie-parser가 쿠키를 생성할 때 쓰이는 것은 아닙니다. 쿠키를 생성/제거하기 위해서는 res.cookie, 
res.clearCookie 메서드를 사용해야 합니다. 
res.cookie(키, 값, 옵션) 형식으로 사용합니다. 
옵션은 4.3절에서 살펴본 쿠키 옵션과 동일합니다. 
domain, expires, httpOnly, maxAge, path, secure등이 있습니다. 

res.cookie('name', 'zerocho', {
    expires : new Date(Date.now() + 900000), 
    httpOnly : true,
    secure : true,
});

res.clearCookie('name', 'zerocho', {httpOnly : true, secure : true});
쿠키를 지우려면, 키와 값 외에도 옵션도 정확히 일치해야 쿠키가 지워집니다. 
단, expires나 maxAge 옵션은 일치할 필요가 없습니다. 
*/

app.use(sessionMiddleware);
app.use(passport.initialize());
app.use(passport.session());

/* 참고
6. 미들웨어의 특성 활용하기
미들웨어를 직접 만들어보기도 했고, 다른 사람이 만든 미들웨어 패키지를 설치해 장착해보기도 했습니다. 
이번 절에서 미들웨어의 특성을 총정리 해봅시다. 

app.use((req, res, next) => {
    console.log('모든 요청에 다 실행됩니다.');
    next();
});

미들웨어는 req, res, next를 매개 변수로 가지는 함수(에러 처리 미들웨어만 예외적으로 err, req, res, next를 가집니다. )로서
app.use나 app.get, app.post 등으로 장착합니다. 
특정한 주소의 요청에만 미들웨어가 실행되게 하려면 첫 번째 인수로 주소를 넣으면 됩니다. 

app.use(
    morgan('dev'),
    express.static(path.join(__dirname, 'public')),
    express.json(),
    express.urlencoded({ extended: false }),
    cookieParser(process.env.COOKIE_SCRECT),
);

위와 같이 동시에 여러개의 미들웨어를 장착할 수 도 있으며, 
다음 미들웨어로 넘어가려면 next 함수를 호출해야 합니다. 
위 미들웨어들은 내부적으로 next를 호출하고 있으므로 연달아 쓸 수 있습니다. 
next를 호출하지 않는 미들웨어는 res.send나 res.sendFile 등의 메서드로 응답을 보내야 합니다. 
express.static과 같은 미들웨어는 정적 파일을 제공할 때 next 대신 res.sendFile 메서드로 응답을 보냅니다. 
따라서 정적 파일을 제공하는 경우 express.json, express.urlencoded, cookieParser 미들웨어는 실행되지 않습니다. 
미들웨어 장착 순서에 따라 어떤 미들웨어는 실행되지 않을 수도 있다는 것을 기억해 둡시다. 

만약 next도 호출하지 않고 응답도 보내지 않으면, 클라이언트는 응답을 받지못해 하염없이 기다리게 됩니다. 

next() => 다음 미들웨어로 
next('route') => 다음 라우터로
next(error) => 에러 핸들러로

next함수에 인수를 넣을 수도 있다. 단, 인수를 넣는다면 특수한 동작을 합니다. 
route라는 문자열을 넣으면 다음 라우터의 미들웨어로 바로 이동하고, 그외의 인수를 넣는 다면 바로 
에러 처리 미들웨어로 이동합니다. 
이때의 인수는 에러처리 미들우어의 err 매개변수가 됩니다. 
라우터에서 에러가 발생할 때 에러를 next(err)을 통해 에러 처리 미들웨어로 넘깁니다. 

미들웨어간에 데이터를 전달하는 방법도 있습니다. 세션을 이용한다면 req.session 객체에 데이터를 
넣어도 되지만, 세션이 유지되는 동안에 데이터도 계속 유지된다는 단점이 있습니다. 
만약 요청이 끝날 때까지만 데이터를 유지하고 싶다면 req 객체에 데이터를 넣어두면 됩니다. 

app.use((req, res, next) => {
    req.data = '데이터 넣기';
    next();
}, (req, res, next) => {
    console.log(req.data); // 데이터 받기
    next();
});

현재 요청이 처리되는 동안 req.data를 통해 미들웨어 간에 데이터를 공유할 수 있습니다. 
새로운 요청이 오면 req.data는 초기화 됩니다. 
속성명이 꼭 data일 필요는 없지만, 다른 미들웨어와 겹치지 않게 조심해야 합니다. 
예를 들어 속성명을 body로 한다면, (req.body) body-Parser 미들웨어와 기능이 겹치게 됩니다. 

<< note : app.set 과의 차이 >>
app.set으로 익스프레스에서 데이터를 저장할 수 있다는 것을 배웠다. 
app.get 또는 req.app.get으로 어디서든지 데이터를 가져올 수 있습니다. 
하지만, app.set을 사용하지 않고 req 객체에 데이터를 넣어서 다음 미들웨어로 전달하는 이유가 있습니다. 
app.set은 익스프레스에서 전역적으로 사용되므로 사용자 개개인의 값을 넣기에는 부적절하며, 
앱 전체의 설정을 공유할 때 사용하면 됩니다. 
req 객체는 요청을 보낸 사용자 개개인에게 귀속되므로 req 객체를 통해 개개인의 데이터를 전달하는 것이 좋습니다. 

미들웨어를 사용할 때 유용한 패턴 한가지를 소개합니다. 
미들웨어 안에 미들웨어를 넣는 방식입니다. 다음 두 방식은 같은 기능을 합니다. 

app.use(morgan('dev'));
// 또는 
app.use((req, res, next) => {
    morgan('dev')(req, res, next);
});

아래 패턴이 유용한 이유는 기존 미들웨어의 기능을 확장할 수 있기 때문입니다. 
예를 들어 다음과 같이 분기 처리를 할 수 도 있습니다. 
조건문에 따라 다른 미들웨어를 적용하는 코드 입니다. 

app.use((req, res, next) => {
    if(process.env.NODE_ENV === 'production') {
        morgan('combined')(req, res, next);
    } else {
        morgan('dev')(req, res, next);
    }
});
*/

app.use('/', indexRouter);
app.use('/auth', authRouter);

app.use((req, res, next)=> {
    const error = new Error(`${req.method} ${req.url} 라우터가 없습니다.`);
    error.status = 404;
    next(error);
});

app.use((err, req, res, next)=> {
    res.locals.message = err.message;
    res.locals.error = process.env.NODE_ENV !== 'production' ? err : {};
    res.status(err.status || 500);
    res.render('error');
});

app.listen(app.get('port'),()=>{
    console.log(app.get('port'), '번 포트에서 대기 중');
});

경매 시스템은 회원 가입, 로그인, 경매 상품 등록, 방 참여, 경매 진행으로 이루어져 있습니다. 
회원 가입, 로그인, 경매 상품 등록 페이지와 라우터를 만들어보겠습니다. 

[views/error.html]
{% extends 'layout.html' %} 

{% block content %} 
    <h1>{{message}}</h1>
    <h2>{{error.status}}</h2>
    <pre>{{error.stack}}</pre>
{% endblock %} 


화면의 레이아웃을 담당하는 layout.html 파일을 작성합니다.
[views/layout.html]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>{{title}}</title>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="/main.css">
  </head>
  <body>
    <div class="container">
      <div class="profile-wrap">
        <div class="profile">
          {% if user and user.id %}
            <div class="user-name">안녕하세요 {{user.nick}}님</div>
            <div class="user-money">보유 자산: {{user.money}}원</div>
            <input type="hidden" id="my-id" value="user.id">
            <a href="/auth/logout" id="logout" class="btn">로그아웃</a>
            <a href="/good" id="register" class="btn">상품 등록</a>
          {% else %}
            <form action="/auth/login" id="login-form" method="post">
              <div class="input-group">
                <label for="email">이메일</label>
                <input type="email" id="email" name="email" required autofocus>
              </div>
              <div class="input-group">
                <label for="password">비밀번호</label>
                <input type="password" id="password" name="password" required>
              </div>
              <a href="/join" id="join" class="btn">회원가입</a>
              <button id="login" class="btn" type="submit">로그인</button>
            </form>
          {% endif %}
        </div>
        <footer>
          Made by&nbsp;<a href="https://www.zerocho.com" target="_blank">TeddyOh</a>
        </footer>
        {% block good %}
        {% endblock %}
      </div>
      {% block content %}
      {% endblock %}
    </div>
    <script>
      window.onload = () => {
        if (new URL(location.href).searchParams.get('loginError')) {
          alert(new URL(location.href).searchParams.get('loginError'));
        }
      };
    </script>
  </body>
</html>

그리고 메인 화면을 담당하는 main.html을 작성합니다.
[views/main.html]
{% extends 'layout.html' %}  

{% block content %} 
    <div class="timeline">
        <h2>경매 진행 목록</h2>
        <table id="good-list">
            <tr>
                <th>상품명</th>
                <th>이미지</th>
                <th>시작 가격</th>
                <th>종료 시간</th>
                <th>입장</th>
            </tr>
            {% for good in goods %} 
                <tr>
                    <td>{{good.name}}</td>
                    <td>
                        <img src="/img/{{good.img}}">
                    </td>
                    <td>{{good.price}}</td>
                    <td class="time" data-start="{{good.createdAt}}">00:00:00</td>
                    <td>
                        <a href="/good/{{good.id}}" class="enter btn">입장</a>
                    </td>
                </tr>
            {% endfor %}  
        </table>
    </div>
{% endblock %}

회원가입을 담당하는 join.html 파일을 작성합니다. 
[views/join.html]
{% extends 'layout.html' %}

{% block content %} 
    <div class="timeline">
        <form action="/auth/login" id="join-form" method="post">
            <div class="input-group">
                <label for="join-email">이메일</label>
                <input type="email" id="join-email" name="email">
            </div>
            <div class="input-group">
                <label for="join-nick">닉네임</label>
                <input type="text" id="join-nick" name="nick">
            </div>
            <div class="input-group">
                <label for="join-password">비밀번호</label>
                <input type="password" id="join-password" name="password">
            </div>
            <div class="input-group">
                <label for="join-money">보유자산</label>
                <input type="number" id="join-money" name="money">
            </div>
            <button id="join-btn" class="btn" type="submit">회원가입</button>
        </form>
    </div>
    <script>
        window.onload =() => {
            if(new URL(location.href).searchParams.get('loginError')) {
                alert(new URL(location.href).searchParams.get('loginError'));
            }
        };
    </script>
{% endblock %}   

상품을 업로드하는 페이지인 good.html 파일을 작성합니다. 
form에서 이미지 업로드(#good-photo)도 해야 하므로 
form 태그의 enctype을 multipart/form-data로 두어 폼 데이터를 사용하도록 설정합니다. 
[views/good.html]
{% extends 'layout.html' %}  

{% block content %} 
    <div class="timeline">
        <form action="/good" id="good-form" method="post" enctype="multipart/form-data">
            <div class="input-group">
                <label for="good-name">상품명</label>
                <input type="text" id="good-name" name="name" required autofocus>
            </div>
            <div class="input-group">
                <label for="good-photo">상품 사진</label>
                <input type="file" id="good-photo" name="img" required>
            </div>
            <div class="input-group">
                <label for="good-price">상품 가격</label>
                <input type="number" id="good-price" name="price" required>
            </div>
            <button id="join-btn" class="btn" type="submit">상품등록</button>
        </form>
    </div>
{% endblock %}   


[public/main.css]
https://offbyone.tistory.com/121
https://www.codingfactory.net/10616
* {box-sizing: border-box;}
html, body {margin:0; padding: 0; height: 100%;}
.btn{
    display: inline-block;
    padding: 0 5px;
    text-decoration: none;
    cursor: pointer;
    border-radius: 4px;
    background: white;
    border: 1px solid silver;
    color : crimson;
    height : 37px;
    line-height: 37px;
    vertical-align: top;
    font-size: 12px;
}
input, textarea {
    border-radius: 4px;
    height: 37px;
    padding: 10px;
    border:1px solid silver;
}
.container {width :100%; height: 100%;}
@media screen and (min-width:800px) {
    .container {width:800px; margin: 0 auto;}
}
.input-group {margin-bottom: 15px;}
.input-group label {width:25%; display: inline-block;}
.input-group input {width: 70%;}
#join{float:right;}
.profile-wrap {
    width : 100%;
    display: inline-block;
    vertical-align: top;
    margin : 10px 0;
}
@media screen and (min-width:800px) {
    .profile-wrap {width:290px; margin-bottom:0;}
}
.profile {
    text-align: left;
    padding: 10px;
    margin-right: 10px;
    border-radius: 4px;
    border: 1px solid silver;
    background: yellow;
}
.user-name, .user-money {
    font-weight: bold;
    font-size: 18px;
    margin-bottom: 10px;
}
.timeline {
    margin-top: 10px;
    width : 100%;
    display: inline-block;
    border-radius: 4px;
    vertical-align: top;
}
@media screen and (min-width:800px) {.timeline {width:500px}}
#good-list, #good-list th, #good-list td {
    border : 1px solid silver;
    border-collapse: collapse;
}
#good-list img {max-height: 100px; vertical-align: top;}
#good-img {width:280px; display:block;}
.error-message {color:red; font-weight: bold;}
#join-form, #good-form {padding: 10px; text-align: center;}
footer {text-align: center;}

마지막으로 라우터를 만듭니다. 
[routes/index.js]
'use strict';

const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const {Good, Auction, User} = require('../models');
const {isLoggedIn, isNotLoggedIn} = require('./middlewares');
const { builtinModules } = require('module');

const router = express.Router();

router.use((req, res, next)=> {
    res.locals.user = req.user;
    next();
});

router.get('/', async(req, res, next)=> {
    try {
        const goods = await Good.findAll({where : {SoldId:null}});
        res.render('main', {
            title : 'NodeAuction',
            goods,
        });
    } catch (error) {
        console.error(error);
        next(error);
    }
});

router.get('/join', (req, res, next)=> {
    res.render('join', {
        title: '회원가입-NodeAuction',
    });
});

router.get('/good', isLoggedIn, (req, res)=> {
    res.render('good', {title:'상품등록-NodeAuction'});
});

try {
    fs.readdirSync('uploads');
} catch(error) {
    console.error('uploads 폴더가 없어 uploads 폴더를 생성합니다.');
    fs.mkdirSync('uploads');
}
const upload = multer({
    storage:multer.diskStorage({
        destination(req, res, cb) {
            cb(null, 'uploads/');
        },
        filename(req, file, cb) {
            const ext = path.extname(file.originalname);
            cb(null, path.basename(file.originalname, ext)+new Date().valueOf()+ext);
        },
    }),
    limits : {fileSize : 5 * 1024 * 1024},
});

router.post('/good', isLoggedIn, upload.single('img'), async(req, res, next)=> {
    try {
        const {name, price} = req.body;
        await Good.create({
            OwnerId : req.user.id,
            name,  
            img : req.file.filename,
            price,
        });
        res.redirect('/');
    } catch(error) {
        console.error(error);
        next(error);
    }
});

module.exports = router;

router.use에서 res.loclas.user = req.user;로 모든 pug 템플릿에 사용자 정보를 
변수로 넣었습니다. 
이러게 하면 res.redner 메서드에 user: req.user를 하지 않아도 되므로 중복을 제거할 수 있습니다. 

라우터는 GET /, GET /join, GET /good, POST /good으로 이루어져 있습니다. 
GET /는 메인 화면을 렌더링 합니다. 
렌더링 할 때 경매가 진행 중인 상품 목록도 같이 불러옵니다. 
SoldId가 낙찰자의 아이디이므로 낙찰자가 null이면 경매가 진행중인 것입니다. 

GET /join과 GET /good은 각각 회원 가입 화면과 상품 등록 화면을 렌더링 합니다. 
POST /good 라우터는 업로드한 상품을 처리합니다.
상품 이미지 업로드 기능이 있어 multer 미들웨어가 붙었습니다. 

이제 npm start 명령어로 서버를 실행한 후 
http://localhost:8010에 접속하면 됩니다. 
회원가입 후 로그인 하고 상품을 등록해 봅시다.



/* 참조>multer 미들웨어
:이미지 동영상 드을 비롯한 여러가지 파일들을 멀티파트 형식으로 업로드 할 때 사용하는 미들웨어 입니다. 
멀티파트 형식이란 다음과 같이 enctype이 multipart/form-data인 폼을 통해 업로드하는 데이터의 형식을 의미합니다. 

multer package 안에는 여러 종류의 미들웨어가 들어있습니다. 미들웨어를 살펴보기 전에 기본적인 설정부터 알아봅시다. 

const multer = require('multer');

const upload = multer({
    storage : multer.diskStorage({
        destination(req, file, done) {
            done(null, 'uploads/');    
        }, 
        filename(req, file, done) {
            const ext = path.extname(file.originalname);
            done(null, path.basename(file.originalname, ext) + Date.now() + ext);
        },
    }),
    limits : {fileSize : 5 * 1024*1024},
});

multer 함수의 인수로 설정을 넣습니다. 
storage 속성에는 어디에(destination) 어떤 이름으로 (filename) 저장할 지를 넣습니다. 
destination과 filename 함수의 req 매개변수에는 요청에 대한 정보가, 
file 객체에는 업로드한 파일에 대한 정보가 있습니다. 
done 매개변수는 함수입니다. 
첫 번째 인수에는 에러가 있다면 에러를 넣고, 두 번째 인수에는 실제 경로나 파일 이름을 넣어주면 됩니다. 
req나 file의 데이터를 가공해서 done으로 넘기는 형식입니다. 

현재 설정으로 uploads 라는 폴더에 [파일명+현재시간.확장자] 파일명으로 업로드 하고 있습니다. 
현재 시간을 넣어주는 이유는 업로드하는 파일명이 겹치는 것을 막기 위해서 입니다. 
limits 속성에는 업로드에 대한 제한 사항을 설정할 수 있습니다. 
파일 사이즈 (fileSize, 바이트 단위)는 5MB로 제한해 두었습니다. 
다만 위 설정을 실제로 활용하기 위해서는 서버에 uploads 폴더가 꼭 존재해야 합니다. 
없다면 직접 만들어주거나 다음과 같이 fs 모듈을 사용해서 서버를 시작할 때 생성합니다. 

const fs = require('fs');

try {
    fs.readdirSync('uploads');
} catch(error) {
    console.log('uploads 폴더가 없어 uploads 폴더를 생성합니다.');
    fs.mkdirSync('uploads');
}

설정이 끝나면 upload 변수가 생기는데, 여기에 다양한 종류의 미들웨어가 들어 있습니다. 
먼저 파일을 하나만 업로드 하는 경우 (multipart.html과 같은 경우)에는 single 미들웨어를 사용합니다. 

app.post('/upload', upload.single('image'), (req, res) => {
    console.log(req.file, req.body);
    res.send('ok');
})

single 미들웨어를 라우터 미들웨어 앞에 넣어두면, multer 설정에 따라 파일 업로드 후 
req.file 객체가 생성됩니다. 인수는 input 태그의 name이나 폼 데이터의 키와 일치하게 넣으면 됩니다. 
업로드 성공시 결과는 req.file 객체 안에 들어 있습니다. 
req.body 에는 파일이 아닌 데이터인 title이 들어 있습니다. 

req.file 객체는 다음과 같이 생겼습니다. 

{
    fieldname : 'img',
    originalname : 'nodejs.png',
    encoding : '7bit',
    mimetype : 'image/png',
    destination : 'uploads/',
    filename: 'nodejs1514197844339.png',
    path : 'uploads\\nodejs1514197844339.png',
    size : 53357
}

여러 파일을 업로드 하는 경우 HTML의 input 태그에는 multiple을 쓰면 됩니다. 
[multipart.html]
<form id="form" action="/upload" method="post" enctype="multipart/form-data">
    <input type="file" name="many" multiple />
    <input type="text" name="title" />
    <button type="submit"> 업로드 </button>
</form>

미들웨어는 single 대신 array로 교체합니다. 

[app.js]
app.post('/upload', upload.array('many'), (req, res) => {
    console.log(req.files, req.body);
    res.send('ok');
});

업로드 결과도 req.file 대신 req.files 배열에 들어 있습니다. 

파일을 여러 개 업로드 하지만 input 태그나 폼 데이터의 키가 다른 경우에는 
fields 미들웨어를 사용합니다. 

[multipart.html]
<form id="form" action="/upload" method="post" enctype="multipart/form-data">
    <input type="file" name="image1" />
    <input type="file" name="image2" />
    <input type="text" name="title" />
    <button type="submit"> 업로드 </button>
</form>

fields 미들웨어의 인수로 input 태그의 name을 각각 적습니다. 

app.post('/upload', 
    upload.fields([{name : 'image1}, {name: 'image2'}]),
    (req, res) => {
        console.log(req.files, req.body);
        res.send('ok');
    },
);

업로드 결과도 req.files.image1, req.files.image2에 각각 들어 있습니다. 

특수한 경우지만, 파일을 업로드하지 않고도 멀티파트 형식으로 업로드 하는 경우가 있습니다. 
그럴 때는 none 미들웨어를 사용합니다. 

[multipart.html]
<form id="form" action="/upload" method="post" enctype="multipart/form-data">
    <input type="text" name="title" />
    <button type="submit"> 업로드 </button>
</form>

[app.js]
app.post('/upload', upload.none(), (req, res) => {
    console.log(req.body);
    res.send('ok');
});
파일을 업로드 하지 않았으므로 req.body만 존재합니다. 

*** multer ***
1.single
1)이미지 하나는 req.file로  
2)나머지 정보는 req.body로

2.array, fields
1)이미지들은 req.files로
2)나머지 정보는 req.body로

3. none
모든 정보를 req.body로 
*/

********2. 서버센트 이벤트 사용하기*******
경매는 시간이 생명입니다. 특히 온라인 경매이므로 모든 사람이 같은 시간에 경매가 종료되어야 합니다.
따라서 모든 사람에게 같은 시간이 표시되어야 합니다. 
하지만 클라이언트의 시간은 믿을 수 없습니다. 너무나도 손쉽게 시간을 변경할 수 있기 때문입니다. 
따라서 서버 시간을 받아오는 것이 좋습니다. 
폴링이나 웹 소켓을 통해 서버시간을 받아올 수 도 있지만, 
이번 예제에서는 서버센트 이벤트를 사용해 서버의 시간을 받아올 것입니다. 
주기적으로 서버시간을 조회하는 데는 양방향 통신이 필요하지 않기 때문입니다. 

웹 소켓도 사용합니다. 웹 소켓은 경매를 진행하는 동안에 다른 사람이 참여하거나 입찰했을 때
모두에게 금액을 알리는 역할을 할 것입니다. 
서버센트 이벤트와 웹 소켓은 같이 사용할 수 있습니다. 

SSE 패키지와 Socket.IO 패키지를 동시에 설치하겠습니다.
$npm i sse socket.io@2


서버와 sse, socket.io 모듈을 연결합니다.
[app.js]
...
const passportConfig = require('./passport');
const sse = require('./sse');
const webSocket = require('./socket');
...
const server = app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기중');
});

webSocket(server, app);
sse(server);

[sse.js]
'use strcit';

const SSE = require('sse');

module.exports = (server) => {
    const sse = new SSE(server);
    sse.on('connection', (client)=> { // 서버센트 이벤트 연결
        setInterval(()=>{
            client.send(Date.now().toString());
        }, 1000);
    });
};

sse 모듈을 불러와 new SSE(익스프레스 서버)로 서버 객체를 형성하면 됩니다. 
생성한 객체에는 connection 이벤트 리스너를 연결하여 클라이언트와 연결할 때 
어떤 동작을 할지 정의할 수 있습니다. 
매개변수 client 객체를 쓸수 있습니다. 
클라이언트에 메세지를 보낼 때 이 객체를 사용합니다. 
라우터에서 SSE 를 사용하고 싶다면 app.set 메서드로 client 객체를 등록하고,
req.app.get 메서드로 가져오면 됩니다. 

1초마다 접속한 클라이언트에 서버 시간 타임스탬프를 보내도록 했습니다. 
client.send 메서드로 보낼 수 있습니다. 
단, 문자열만 보낼 수 있으므로 숫자인 타임스탬프를 toString 메서드를 사용하여 
문자열로 변경했습니다. 

[socket.js]
'use strict';

const SocketIO = require('socket.io');

module.exports = (server, app) => {
    const io = SocketIO(server, {path:'/socket.io'});
    app.set('io', io);
    io.on('connection', (socket)=> { // 웹 소켓 연결시 
        const req = socket.request;
        const {headers : {referer}} = req;
        const roomId = referer.split('/')[referer.split('/').length-1];
        socket.join(roomId);
        socket.on('disconnection', ()=> {
            socket.leave(roomId);
        });
    });
};

Socket.IO와도 연결합니다. 이번에는 사용자 정의 네임스페이스를 쓰지 않고 
기본 네임 스페이스(/)로 연결 했습니다. 
app.set('io', io)로 라우터에서 io 객체를 쓸 수 있게 저장해 둡니다. 
req.app.get('io')로 접근할 수 있습니다. 
경매 화면에서 실시간으로 입찰 정보를 올리기 위해 웹 소켓을 사용합니다. 
클라이언트 연결 시 주소로부터 경매방 아이디를 받아와 socket.join으로 해당 방에 입장합니다.
연결이 끊겼다면 socket.leave로 해당 방에서 나갑니다. 

서버벤트 이벤트는 한가지 단점이 있습니다. 
IE나 엣지 브라우저에서 사용할 수 없다는 것입니다. 
EventSource 라는 객체를 지원하지 않기 때문인데, 
다행히 EventSource를 사용자가 직접 구현할 수 있습니다.
IE나 엣지 브라우저를 위해 클라이언트 코드에 EventSource 폴리필(polyfill)을 넣었습니다. 

[views/main.html]
.....
{% endfor %}
    </table>
  </div>
  <script src="https://unpkg.com/event-source-polyfill/src/eventsource.min.js"></script>
  <script>
    const es = new EventSource('/sse');
    es.onmessage = function(e) {
      document.querySelectorAll('.time').forEach((td)=> {
        const end = new Date(td.dataset.start); //경매 시작 시간
        const server = new Date(paresInt(e.data, 10));
        end.setDate(end.getDate()+1); //경매 종료 시간
        if(server >= end) { //경매가 종료되었으면,
          return td.textContent='00:00:00';
        } else {
          const t = end - server; //경매 종료까지 남은 시간
          const seconds = ('0' + Math.floor((t/1000)%60)).slice(-2);
          const minutes = ('0' + Math.floor((t/1000/60)%60)).slice(-2);
          const hours = ('0' + Math.floor((t/(1000*60*60))%24)).slice(-2);
          return td.textContent = hours + ':' + minutes + ':' + seconds;
        }
      });
    };
  </script>
{% endblock %}

첫 번째 스크립트가 EventSource 폴리필입니다. 
이것을 넣으면 IE와 엣지 브라우저에서도 서버센트 이벤트를 사용할 수 있습니다. 
두 번째 스크립트는 EventSource를 사용해 서버센트 이벤트를 받는 코드입니다. 
new EventSource('/sse) 로 서버와 연결하고, es.onmessage 또는 
es.addEventListener('message') 이벤트 리스너로 서버로부터 데이터를 받을 수 있습니다. 
서버로 부터 받은 데이터는 e.data에 들어있습니다. 
아랫 부분은 서버 시간과 경매 종료 시간을 계산해 카우트다운하는 코드입니다. 
24시간동안 카운트다운되도록 했습니다. 

이제 경매를 진행하는 페이지를 만들어보겠습니다. 
이 페이지는 서버센트 이벤트와 웹 소켓 모두에 연결합니다.
[views/auction.html]
{% extends 'layout.html' %}

{% block good %}
  <h2>{{good.name}}</h2>
  <div>등록자: {{good.Owner.nick}}</div>
  <div>시작가: {{good.price}}원</div>
  <strong id="time" data-start="{{good.createdAt}}"></strong>
  <img id="good-img" src="/img/{{good.img}}">
{% endblock %}

{% block content %}
  <div class="timeline">
    <div id="bid">
      {% for bid in auction %}
        <div>
          <span>{{bid.User.nick}}님: </span>
          <strong>{{bid.bid}}원에 입찰하셨습니다.</strong>
          {% if bid.msg %}
            <span>({{bid.msg}})</span>
          {% endif %}
        </div>
      {% endfor %}
    </div>
    <form id="bid-form">
      <input type="number" name="bid" placeholder="입찰가" required min="{{good.price}}">
      <input type="msg" name="msg" placeholder="메시지(선택사항)" maxlength="100">
    <button class="btn" type="submit">입찰</button>
    </form>
  </div>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script src="https://unpkg.com/event-source-polyfill/src/eventsource.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    document.querySelector('#bid-form').addEventListener('submit', (e) => {
      e.preventDefault();
      const errorMessage = document.querySelector('.error-message');
      axios.post('/good/{{good.id}}/bid', { // 입찰 진행
        bid: e.target.bid.value,
        msg: e.target.msg.value,
      })
        .catch((err) => {
          console.error(err);
          alert(err.response.data);
        })
        .finally(() => {
          e.target.bid.value = '';
          e.target.msg.value = '';
          errorMessage.textContent = '';
        });
    });
    const es = new EventSource("/sse");
    const time = document.querySelector('#time');
    es.onmessage = (e) => {
      const end = new Date(time.dataset.start); // 경매 시작 시간
      const server = new Date(parseInt(e.data, 10));
      end.setDate(end.getDate() + 1); // 경매 종료 시간
      if (server >= end) { // 경매가 종료되었으면
        return time.textContent = '00:00:00';
      } else {
        const t = end - server;
        const seconds = ('0' + Math.floor((t / 1000) % 60)).slice(-2);
        const minutes = ('0' + Math.floor((t / 1000 / 60) % 60)).slice(-2);
        const hours = ('0' + Math.floor((t / (1000 * 60 * 60)) % 24)).slice(-2);
        return time.textContent = hours + ':' + minutes + ':' + seconds;
      }
    };
    const socket = io.connect('http://localhost:8010', {
      path: '/socket.io'
    });
    socket.on('bid', (data) => { // 누군가가 입찰했을 때
      const div = document.createElement('div');
      let span = document.createElement('span');
      span.textContent = data.nick + '님: ';
      const strong = document.createElement('strong');
      strong.textContent = data.bid + '원에 입찰하셨습니다.';
      div.appendChild(span);
      div.appendChild(strong);
      if (data.msg) {
        span = document.createElement('span');
        span.textContent = `(${data.msg})`;
        div.appendChild(span);
      }
      document.querySelector('#bid').appendChild(div);
    });
  </script>
  <script>
    window.onload = () => {
      if (new URL(location.href).searchParams.get('auctionError')) {
        alert(new URL(location.href).searchParams.get('auctionError'));
      }
    };
  </script>
{% endblock %}

스트립트 코드가 상당히 길지만 별 내용은 없습니다. 
먼저 axios, EventSource 폴리필과 Socket.IO 클라이언트 스크립트를 넣었습니다. 
네 번째 스크립트 태그는 입찰 시 POST/good/:id/bid로 요청을 보내는 것,
서버센트 이벤트 데이터로 서버 시간을 받아 카운트다운하는 것,
다른 사람이 입찰했을 때 Socket.IO로 입찰 정보를 렌더링 하는 것으로 이루어져 있습니다. 

이제 라우터에 GET/good/:id와 POST/good/:id/bid를 추가합니다. 
[routes/index.js]
...

router.get('/good/:id', isLoggedIn, async(req, res, next)=> {
  try {
    const [good, auction] = await Promise.all([
      Good.findOne({
        where:{id:req.params.id},
        include: {
          model : User,
          as : 'Owner',
        },
      }),
      Auction.findAll({
        where : {GoodId : req.params.id},
        include : {model :User},
        order:[['bid', 'ASC'],]
      }),
    ]);
    res.render('acution', {
      title:`${good.name} - NodeAuction`,
      good,
      auction,
    });
  } catch(error) {
    console.error(error);
    next(error);
  }
});

router.post('/good/:id/bid', isLoggedIn, async(req, res, next)=> {
  try {
    const {bid, msg} = req.body;
    const good = await Good.findOne({
      where : {id:req.params.id},
      include : {model : Auction},
      order:[[{model : Auction}, 'bid', 'DESC']],
    });
    if(good.price >= bid) {
      return res.status(403).send('시작 가격보다 높게 입찰해야 합니다.');
    }
    if(new Date(good.createdAt).valueOf()+(24*60*60*1000)<new Date()) {
      return res.status(403).send('경매가 이미 종료되었습니다.');
    }
    if(good.Auctions[0] && good.Auctions[0].bid >= bid) {
      return res.status(403).send('이전 입찰가보다 높아야 합니다.');
    }
    const result = await Auction.create({
      bid,
      msg,
      UserId : req.params.id,
      GoodId : req.params.id,
    });
    //실시간으로 입찰 내역 전송
    req.app.get('io').to(req.params.id).emit('bid', {
      bid : result.bid,
      msg : result.msg,
      nick : req.params.nick,
    });
    return res.send('ok');
  } catch(error) {
    console.error(error);
    next(error);
  }
});

module.exports = router;

GET /good/:id 라우터는 해당 상품과 기존 입찰 정보들을 불러온 뒤 렌더링합니다.
상품(Good) 모델에 사용자(User) 모델을 include할 때 as 속성을 사용한 것에 주의하세요.
Good모델과 User모델은 현재 일대 다 관계가 두번 연결(Owner, Sold)되어 있으므로 
이런 경우에는 어떤 관계를 include할지 as 속성으로 밝혀야 합니다.

POST /good/:id/bid는 클라이언트로부터 받은 입찰 정보를 저장합니다. 
만약 시작 가격보다 낮게 입찰했거나, 경매 종료 시간이 지났거나, 이전 입찰가보다 낮은 입찰가가
들어왔다면 반려합니다. 
정상적인 입찰가가 들어왔다면 저장한 후 해당 경매방의 모든 사람에게 입찰자, 입찰 가격, 입찰 메세지등을
웹속켓으로 전달합니다.
Good.findOne 메서드의 order 속성을 눈여겨 보길 바랍니다. 
include될 모델의 컬럼을 정렬하는 방법입니다. 
Auction모델의 bid를 내림차순으로 정렬하고 있습니다. 

이제 서버에 연결해서 경매를 시작해보겠습니다. 
브라우저를 두개 띄워서 각자 다른 아이디로 로그인한 후 진행해보세요.



*******3. 스케쥴링 구현하기 *******
카운트다운이 끝나면 더 이상 경매를 진행할 수는 없지만, 아직 낙찰자가 정해지지 않았습니다. 
경매 종료를 24시간 후로 정했으므로 경매가 생성되고, 24시간이 지난 후에 낙찰자를 정하는 
시스템을 구현해야 합니다. 
이럴 때 node-schedule 모듈을 사용합니다. 

$npm i node-schedule

[routes/index.js]
.......
const schedule = require('node-schedule');

const {Good, Auction, User} = require('../models');
const {isLoggedIn, isNotLoggedIn} = require('./middlewares');

......
router.post('/good', isLoggedIn, upload.single('img'), async(req, res, next)=> {
    try {
        const {name, price} = req.body;
        const good = await Good.create({
            OwnerId : req.user.id,
            name,  
            img : req.file.filename,
            price,
        });
        const end = new Date();
        end.setDate(end.getDate()+1);//하루뒤
        schedule.scheduleJob(end, async()=> {
          const success = await Auction.findOne({
            where : {GoodId:good.id},
            order :[['bid', 'DESC']],
          });
          await Good.update({SoldId : success.UserId}, {where:{id:good.id}});
          await User.update({
            money : sequelize.literal(`money-${success.bid}`),
          }, {
            where:{id:success.UserId},
          });
        });
        res.redirect('/');
    } catch(error) {
        console.error(error);
        next(error);
    }
});

schedule 객체의 scheduleJob 메서드로 일정을 예약할 수 있습니다. 
첫 번째 인수로 실행될 시작을 넣고, 
두번 째 인수로 해당 시각이 되었을 때 수행할 콜백함수를 넣습니다. 
경매 모델에서 가장 높은 가격으로 입찰한 사람을 찾아 상품 모델의 낙찰자 아이디에 
넣어주도록 정의했습니다. 
또한 낙찰자의 보유 자산을 낙찰 금액만큼 뺍니다. 
{컬럼 : sequelize.literal(컬럼-숫자)}가 시퀄라이즈에서 해당 컬럼의 숫자를 줄이는 방법입니다. 
숫자를 늘리려면 - 대신 =를 하면 됩니다. 

node-schedule 패키지의 단점은 스케줄링이 노드 기반으로 작동하므로 노드가 종ㄹ료되면 
스케쥴 예약도 같이 종료된다는 점입니다 
노드를 계속 켜두면 되지만, 서버가 어떤 에러로 인해 종료될 지 예측하기는 매우 어렵습니다. 
따라서 이를 보완하기 위한 방법이 필요합니다. 
서버가 시작될 때 경매 시작 후 24시간이 지났지만 낙찰자가 없는 경매를 찾아서 낙찰자를 
지정하는 코드를 추가해보겠습니다. 

[checkAuction.js]
'use strict';

const {Op} = requrie('Sequelize');

const {Good, Auction, User, sequelize} = require('./modles');

module.exports = async() => {
    try {
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate()-1); //어제 시간
        const targets = await Good.findAll({
            where: {
                SoldId : null,
                createAt : {[Op.lte]:yesterday},
            },
        });
        targets.array.forEach(async(target)=> {
            const success = await Auction.findOne({
                where : {GoodId : target.id},
                order : [['bid', 'DESC']],
            });
            await Good.update({SoldId : success.UserId}, {where:{id:target.id}});
            await User.update({
                money : sequelize.literal(`money-${success.bid}`),
            }, {
                where : {id:success.UserId},
            });
        });
    } catch(error) {
        console.error(error);
    }
};

낙찰자가 없으면서 생성된지 24시간이지난 경매를 찾아 낙찰자를 정합니다. 

[app.js]
.....
dotenv.config();
const indexRouter = require('./routes/index');
const authRouter = require('./routes/auth');
const { sequelize } = require('./models');
const passportConfig = require('./passport');
const sse = require('./sse');
const webSocket = require('./socket');
const checkAuction = require('./checkAuction');

const app = express();
passportConfig();
checkAuction();
app.set('port', process.env.PORT || 8010);
.....

checkAuction을 서버에 연결합니다. 
서버를 재 시작하면 앞으로 서버를 시작할 때마다 낙찰자를 지정하는 작업을 수행합니다.
checkAuction의 코드는 app.js에 직접 작성해도 되지만 코드가 길어지므로 분리했습니다.

하루가 지나 경매가 마무리되면 node-schedule 모듈이 예정된 스케줄에 따라 낙찰자를 지정합니다. 
단, 서버가 계속 켜져 있어야 합니다. 
서버가 중간에 꺼졌다면 다시 켤 때 checkAuction.js 코드에 따라 낙찰자를 선정하게 됩니다. 

지금까지 경매 시스템을 제작해 봤습니다. 
마지막으로 낙찰자가 낙찰 내역을 볼 수 있도록 해보겠습니다. 

[routes/index.js]
.....
router.get('/list', isLoggedIn, async(req, res, next)=> {
  try {
    const goods = await Good.findAll({
      where : {SoldId : req.user.id},
      include : {model : Auction},
      order : [[{model:Auction}, 'bid', 'DESC']],
    });
    res.render('list', {title: '낙찰 목록 - NodeAcution', goods});
  } catch(error) {
    console.error(error);
    next(error);
  }
});

module.exports = router;

낙찰된 상품과 그 상품의 입찰 내역을 조회한 후 렌더링 합니다. 
입찰내역은 내림차순으로 정렬하여 낙찰자의 내역이 가장 위에 오도록합니다.

[views/list.html]
{% extends 'layout.html' %} 

{% block content %} 
    <div class="timeline">
        <h2>경매 낙찰 목록</h2>
        <table id="good-list">
            <tr>
                <td>상품명</td>
                <td>사진</td>
                <td>낙찰가</td>
            </tr>
            {% for good in goods %} 
                <tr>
                    <td>{{good.name}}</td>
                    <td>
                        <img src="/img/{{good.img}}">
                    </td>
                    <td>{{good.Auctions[0].bid}}</td>
                </tr>
            {% endfor %} 
        </table>
    </div>
{% endblock %} 

낙찰 목록 화면을 추가합니다. 

[views/layout.html]
.....
     {% if user and user.id %}
            <div class="user-name">안녕하세요 {{user.nick}}님</div>
            <div class="user-money">보유 자산: {{user.money}}원</div>
            <input type="hidden" id="my-id" value="user.id">
            <a href="/auth/logout" id="logout" class="btn">로그 아웃</a>
            <a href="/good" id="register" class="btn">상품 등록</a>
            <a href="/list" id="lsit" class="btn">낙찰 내역</a>
          {% else %}
.....

낙찰 목록으로 이동할 수 있는 버튼을 추가했습니다. 
낙찰자의 계저으로 로그인 하면 http://localhost:8010/list에서 낙찰된 목록을 확인할 수있습니다. 

note>> 운영체제의 스케줄러
node-schedule 패키지로 등록한 스케줄은 노드 서버가 종료될 때 같이 종료된다는 단점이 있습니다. 
이를 극복하려면 운영체제의 스케줄러를 사용하는 것이 좋습니다. 
윈도에서는 schatasks가 대표적이고, 맥과 리눅스에서는 cron이 대표적입니다. 
노드에서는 이 두 프로그램의 명령어를 child-process를 통해 호출할 수 있습니다. 


***핵심정리***
1.서버에서 클라이언트로 보내는 일방향 통신은 웹소켓대신 서버센트 이벤트를 사용해도 됩니다. 
2.기존 입찰 내역은 데이터 베이스에서 불러오고, 
방 참여 후에 추가되는 내역은 웹 소켓에서 불러옵니다. 
이둘을 매끄럽게 연결하는 방법을 기억해 둡시다. 
3. 코드가 길어질 것 같으면 app.js로 부터 socket.js와 checkAuction.js 처럼 분리합니다. 
4. 사용자의 입력값은 프러트엔드와 백엔드 모두에서 체크하는 것이 좋습니다. 
5. 스케줄링을 통해 주기적으로 일어나는 작업을 처리 할 수 있지만, 노드 서버가 계속 
켜져있어야 하므로 노드 서버가 꺼졌을 때 대처할 방법을 마련해야 합니다. 
